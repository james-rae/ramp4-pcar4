import { h, g as g$1, d as d$1, O as O$1, l as l$1, a as a$1, u, f, L, s, i as i$2 } from './main-CGBWc59Z.js';
import { i } from './originUtils-Do2K3Z97.js';
import { $ as $$1, w, I, v, j as j$1, y, P as P$1, l, d, c } from './utils-DbnOqzmT.js';
import { t, a, i as i$1 } from './fetchService-BSiheFNT.js';
import './preload-helper-dJJaZANz.js';
import './multiOriginJSONSupportUtils-C5oGZ9U0.js';
import './jsonContext-CLNEFAHJ.js';
import './saveAPIKeyUtils-EUYYaWcY.js';
import './saveUtils-BK0O4joz.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
const P="Feature Service",E="feature-layer-utils",$=`${E}-save`,x=`${E}-save-as`,N=`${E}-saveall`,g=`${E}-saveall-as`;function O(e){return {isValid:L(e)&&("feature"!==e.type||!e.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function U(e){const r=[],a=[];for(const{layer:t,layerJSON:n}of e)t.isTable?a.push(n):r.push(n);return {layers:r,tables:a}}function j(e){return U([e])}async function J(e,r){return /\/\d+\/?$/.test(e.url)?j(r[0]):M(r,e)}async function M(e,r){if(e.reverse(),!r)return U(e);const a=await R(r,e);for(const t of e)k(t.layer,t.layerJSON,a);return K(a,e),a}async function R(e,r){let a=await e.fetchData("json");if(D(a))return a;a||={},F(a);const{layer:{url:t,customParameters:n,apiKey:o}}=r[0];return await z(a,{url:t??"",customParameters:n,apiKey:o},r.map((e=>e.layer.layerId))),a}function D(e){return !!(e&&Array.isArray(e.layers)&&Array.isArray(e.tables))}function F(e){e.layers||=[],e.tables||=[];}function K(e,r){const a=[],t=[];for(const{layer:n}of r){const{isTable:e,layerId:r}=n;e?t.push(r):a.push(r);}Y(e.layers,a),Y(e.tables,t);}function Y(r,a){if(r.length<2)return;const t=[];for(const{id:e}of r)t.push(e);h(t.sort(_),a.slice().sort(_))&&r.sort(((e,r)=>{const t=a.indexOf(e.id),n=a.indexOf(r.id);return t<n?-1:t>n?1:0}));}function _(e,r){return e<r?-1:e>r?1:0}async function z(e,r,a){const{url:t$1,customParameters:n,apiKey:o}=r,{serviceJSON:s,layersJSON:i}=await t(t$1,{customParameters:n,apiKey:o}),l=G(e.layers,s.layers,a),c=G(e.tables,s.tables,a);e.layers=l.itemResources,e.tables=c.itemResources;const u=[...l.added,...c.added],p=i?[...i.layers,...i.tables]:[];await B(e,u,t$1,p);}function G(e,a,t){const n=g$1(e,a,((e,r)=>e.id===r.id));e=e.filter((e=>!n.removed.some((r=>r.id===e.id))));const o=n.added;return o.forEach((({id:r})=>{e.push({id:r});})),{itemResources:e,added:o.filter((({id:e})=>!t.includes(e)))}}async function B(e,r,a,t){const n=await V(r),o=r.map((({id:e,type:r})=>new(n.get(r))({url:a,layerId:e,sourceJSON:t.find((({id:r})=>r===e))})));await Promise.allSettled(o.map((e=>e.load()))),o.forEach((r=>{const{layerId:a,loaded:t,defaultPopupTemplate:n}=r;if(!t||null==n)return;const o={id:a,popupInfo:n.toJSON()};"ArcGISFeatureLayer"!==r.operationalLayerType&&(o.layerType=r.operationalLayerType),k(r,o,e);}));}async function V(e){const r=[];e.forEach((({type:e})=>{const a$1=i$1(e),t=a[a$1];r.push(t());}));const a$1=await Promise.all(r),t=new Map;return e.forEach((({type:e},r)=>{t.set(e,a$1[r]);})),t}function k(e,r,a){e.isTable?q(a.tables,r):q(a.layers,r);}function q(e,r){const a=e.findIndex((({id:e})=>e===r.id));-1===a?e.push(r):e[a]=r;}function C(e,r){if(!e.length)throw new s(`${r}:missing-parameters`,"'layers' array should contain at least one feature layer")}function H(e,r){const a=e.map((e=>e.portalItem.id));if(new Set(a).size>1)throw new s(`${r}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")}function Q(e,r){const a=e.map((e=>e.layerId));if(new Set(a).size!==a.length)throw new s(`${r}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function W(e){C(e,N),await Promise.all(e.map((e=>e.load())));for(const r of e)l(r,N,O),d({layer:r,itemType:P,errorNamePrefix:N});H(e,N),Q(e,N);}async function X(e,r){const{url:a,layerId:t,title:n,fullExtent:o,isTable:s}=e,i=d$1(a);r.url=("FeatureServer"===i?.serverType?a:`${a}/${t}`)??null,r.title||=n,r.extent=null,s||null==o||(r.extent=await l$1(o)),a$1(r,f.METADATA),a$1(r,f.MULTI_LAYER),i$2(r,f.SINGLE_LAYER),s&&i$2(r,f.TABLE);}function Z(e,r){for(const s$1 of e){const a=s$1.parsedUrl.path,n=d$1(a),o=n?.url.path;if(!o)throw new s(`${r}:invalid-parameters`,c(s$1,`has unsupported url pattern: ${a}`),{layer:s$1});const i=n?.serverType;if("FeatureServer"!==i&&"MapServer"!==i)throw new s(`${r}:invalid-parameters`,c(s$1,`has unsupported server type: ${i}`),{layer:s$1});if("MapServer"===i&&e.length>1)throw new s(`${r}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const a=d$1(e[0].parsedUrl.path),n=a?.url.path,o=e.every((e=>{const r=d$1(e.parsedUrl.path);return r?.url.path===n}));if(!o)throw new s(`${r}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")}async function ee(e){C(e,g),await Promise.all(e.map((e=>e.load())));for(const r of e)l(r,g,O);Z(e,g),Q(e,g);}async function re(e,r){let t=0,n=0;for(const{isTable:a}of r)a?n++:t++;const o=r[0].parsedUrl.path,s=d$1(o);if(e.url="FeatureServer"===s?.serverType?s.url.path:o,e.title||=s.title,e.extent=null,t>0){const t=r.map((e=>e.fullExtent)).filter(O$1).reduce(((e,r)=>e.clone().union(r)));t&&(e.extent=await l$1(t));}a$1(e,f.METADATA),u(e,f.MULTI_LAYER,r.length>1),u(e,f.SINGLE_LAYER,1===r.length),u(e,f.TABLE,n>0&&0===t),v(e);}async function ae(e,r){return $$1({layer:e,itemType:P,validateLayer:O,createItemData:(e,r)=>J(r,[e]),errorNamePrefix:$},r)}async function te(e,r){await W(e);const a=e[0].portalItem,t=w(a),o=await Promise.all(e.map((e=>I(e,t,r)))),c=await J(a,e.map(((e,r)=>({layer:e,layerJSON:o[r]}))));return v(a),await a.update({data:c}),await Promise.all(e.slice(1).map((e=>e.portalItem.reload()))),i(t),a.clone()}async function ne(e,r,a){return j$1({layer:e,itemType:P,validateLayer:O,createItemData:(e,r)=>Promise.resolve(j(e)),errorNamePrefix:x,newItem:r,setItemProperties:X},a)}async function oe(e,r,a){await ee(e);const t=y({itemType:P,errorNamePrefix:g,newItem:r}),o=w(t),l=await Promise.all(e.map((e=>I(e,o,a)))),c=await M(e.map(((e,r)=>({layer:e,layerJSON:l[r]}))));await re(t,e),await P$1(t,c,a);for(const n of e)n.portalItem=t.clone();return i(o),t}

export { ae as save, te as saveAll, oe as saveAllAs, ne as saveAs };
