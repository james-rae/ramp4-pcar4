import { bu as J$1, cz as n, g7 as H$1, ap as n$1, g8 as B$1, g9 as x, ga as j, cG as c$1, gb as f$1, cL as h, cA as j$1, f7 as z$1, gc as j$2, G as n$2, dJ as e$3, er as O$1 } from './main-CGBWc59Z.js';
import { e as e$2 } from './mat3f64-BNcPSU_3.js';
import { o, e as e$1 } from './mat4f64-UGgSIQpQ.js';
import { a } from './spatialReferenceEllipsoidUtils-CSBdmRmv.js';
import { u } from './computeTranslationToOriginAndRotation-DPVyOv1o.js';
import { m } from './meshVertexSpaceUtils-Do5BvCCu.js';
import { i, e, f as f$2 } from './vec3-BxZ5yrM4.js';
import { logProjectionError as S, transformNormal as V$1, transformTangent as B$2, projectFromPCPF as G$1, projectNormalFromPCPF as k$1, projectTangentFromPCPF as q$1, projectToPCPF as w, projectNormalToPCPF as v, projectTangentToPCPF as Y$1 } from './projection-Do8NJvYY.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
function c(e,o,c,i){if(J$1(e.spatialReference,c)){f[0]=e.x,f[1]=e.y;const r=e.z;return f[2]=r??i??0,n(f,e.spatialReference,0,o,c,0,1)}const s=H$1(e,c);return !!s&&(o[0]=s?.x,o[1]=s?.y,o[2]=s?.z??i??0,!0)}const f=n$1();

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
const G=()=>n$2.getLogger("esri.geometry.support.meshUtils.vertexSpaceConversion");function N(t,n,{vertexSpace:r,spatialReference:e}){if("georeferenced"===r.type){const o=t;if(!c(n,o,e))return !1;const{origin:i}=r;return e$3(t,o,i),!0}const o=a(e),i=t;if(!c(n,i,o))return !1;const{origin:a$1}=r,s=tt;if(!u(e,a$1,s,o))return !1;const c$1=h(tt,s);return null!=c$1&&(O$1(t,i,c$1),!0)}function M(t,r,e){const{vertexSpace:o$1,transform:i,vertexAttributes:l}=t,s=J(t.spatialReference,e,nt.SOURCE|nt.TARGET);if(m(o$1,r)&&(!i||B$1(i.localMatrix,o))&&x(s,1)){const{position:t,normal:n,tangent:r}=l,o=e?.allowBufferReuse;return {position:o?t:t.slice(),normal:o?n:n?.slice(),tangent:o?r:r?.slice()}}switch(t.vertexSpace.type){case"local":return "local"===r.type?P(t,t.vertexSpace,r.origin,e):B(t,t.vertexSpace,r.origin,e);case"georeferenced":return "local"===r.type?L(t,t.vertexSpace,r.origin,e):k(t,t.vertexSpace,r.origin,e)}}function k({vertexAttributes:t,transform:n,spatialReference:r},{origin:e},o,i$1){const{position:l,normal:a,tangent:s}=n?q(t,n.localMatrix):t,c=new Float64Array(l.length);let u=l;if(e&&(u=i(c,u,e)),o){const t=j(_,o);u=i(c,u,t);}J(r,i$1,nt.NONE);const f=i$1?.allowBufferReuse;return {position:u!==t.position||f?u:u.slice(),normal:a!==t.normal||f?a:a?.slice(),tangent:s!==t.tangent||f?s:s?.slice()}}function B({spatialReference:t,vertexAttributes:n,transform:r},{origin:e},o,i$1){const l=a(t);if(!u(t,e,Y,l))return S(G(),t,l),null;r&&c$1(Y,Y,r.localMatrix),I(Y,t,i$1,nt.SOURCE);const a$1=new Float64Array(n.position.length),c=z(n.position,Y,t,a$1);if(!c)return null;const u$1=D(c,a$1,n.normal,Y,t);if(n.normal&&!u$1)return null;const f=H(c,a$1,n.tangent,Y,t);if(n.tangent&&!f)return null;if(o){const t=j(_,o);i(c,c,t);}return {position:c,normal:u$1,tangent:f}}function L({vertexAttributes:t,spatialReference:n,transform:r},{origin:e},i,a$1){const s=a(n);if(!u(n,i,Y,s))return S(G(),n,s),null;const u$1=1/J(n,a$1,nt.TARGET);f$1(Y,Y,[u$1,u$1,u$1]);const f=h(Z,Y),{position:m,normal:p,tangent:g}=V(t,e,r),x=new Float64Array(m.length),v=K(m,n,f,x);if(!v)return null;const R=j$1($,f),j=Q(p,m,x,n,R,p!==t.normal?p:void 0);if(!j&&p)return null;const w=W(g,m,x,n,R,g!==t.tangent?g:void 0);return !w&&g?null:{position:v,normal:j,tangent:w}}function V(t,n,r){if(!n)return t;if(!r){const{position:r,normal:e,tangent:o}=t;return {position:i(new Float64Array(r.length),r,n),tangent:o,normal:e}}const e=q(t,r.localMatrix);return i(e.position,e.position,n),e}function P({vertexAttributes:t,spatialReference:n,transform:r},{origin:e},o,i){const a$1=a(n);if(!u(n,e,Y,a$1))return S(G(),n,a$1),null;if(r&&c$1(Y,Y,r.localMatrix),!u(n,o,Z,a$1))return S(G(),a$1,n),null;h(Z,Z);const c=c$1(Y,Z,Y);return I(c,n,i,nt.SOURCE|nt.TARGET),q(t,c)}function q(t,n){const r=new Float64Array(t.position.length);e(r,t.position,n);const e$1=t.normal?new Float32Array(t.normal.length):null,o=t.tangent?new Float32Array(t.tangent.length):null;return e$1&&t.normal&&V$1(t.normal,e$1,n),o&&t.tangent&&B$2(t.tangent,o,n),{position:r,normal:e$1,tangent:o}}function z(t,n,r,e$1){e(e$1,t,n);const o=new Float64Array(t.length);return G$1(e$1,o,r)?o:(S(G(),a(r),r),null)}function D(t,n,r,e,o){if(null==r)return null;const i=new Float32Array(r.length);return V$1(r,i,e),k$1(i,t,n,o,i)?i:(S(G(),a(o),o),null)}function H(t,n,r,e,o){if(null==r)return null;const i=new Float32Array(r.length);return B$2(r,i,e),q$1(i,t,n,o,i)?i:(S(G(),a(o),o),null)}function I(t,n,r,e){const o=J(n,r,e);1!==o&&f$1(t,t,[o,o,o]);}function J(t,n,r){const e=!!(r&nt.SOURCE),o=!!(r&nt.TARGET),i=n?.sourceUnit,l=n?.targetUnit;if(!i&&!l)return 1;let a=X(i,t);!e&&i&&1!==a&&(G().warn("source unit conversion not supported"),a=1);let s=1/X(l,t);return !o&&l&&1!==s&&(G().warn("target unit conversion not supported"),s=1),a*s}function K(t,n,r,e$1){const o=w(t,n,e$1);if(!o)return S(G(),n,a(n)),null;const i=new Float64Array(o.length);return e(i,o,r),i}function Q(t,n,r,e,o,i){if(null==t)return null;const l=i??new Float32Array(t.length);return v(t,n,r,e,l)?(f$2(l,l,o),l):(S(G(),e,a(e)),null)}function W(t,n,r,e,o,i){if(null==t)return null;const l=i??new Float32Array(t.length);return Y$1(t,n,r,e,l)?(f$2(l,l,o,4),l):(S(G(),e,a(e)),null)}function X(t,n){if(null==t)return 1;const o=z$1(n);return 1/j$2(o,"meters",t)}const Y=e$1(),Z=e$1(),$=e$2(),_=n$1(),tt=e$1();var nt;!function(t){t[t.NONE=0]="NONE",t[t.SOURCE=1]="SOURCE",t[t.TARGET=2]="TARGET";}(nt||(nt={}));

export { M, N, X, c };
