import{NonSimpleResult as R}from"./OperatorDefinitions-DJdq_wrt.js";import{execute as N}from"./affineTransformOperator-CI2wZwde.js";import{an as l,bJ as G,fl as g}from"./main-B6st6mg0.js";import{u as h,a as D,s as q,i as I,c as A}from"./operatorGeodesicBuffer-C8iREZqV.js";import{e as P}from"./geodeticCurveType-D_etKnbP.js";import{m as B}from"./geodeticAreaOperator-BRWf8LY7.js";import{f as J}from"./geodeticAreaOperator-BRWf8LY7.js";import{l as L}from"./geodeticDensifyOperator-C5LuyH7C.js";import{g as W}from"./geodeticDensifyOperator-C5LuyH7C.js";import{m as Y}from"./geodeticLengthOperator-BoAj4cTT.js";import{f as E}from"./geodeticLengthOperator-BoAj4cTT.js";import{isSimple as F}from"./simplifyOGCOperator-Dk4Qlqnl.js";import H from"./Transformation-CZH2U6RZ.js";import{i as Q}from"./areaOperator-OaTltSSN.js";import{x as V,l as X,f as Z}from"./operatorBuffer-DfXTex2_.js";import{getSpatialReference as i,fromGeometry as r,fromSpatialReference as n,toPolygon as w,toGeometry as y}from"./apiConverter-r-Dz8Yjc.js";import{p as $}from"./centroidOperator-kbXAe879.js";import{i as k}from"./clipOperator-icyUqmdi.js";import{u as K}from"./containsOperator-CIo2DTZE.js";import{q as U,D as ee,_ as te,w as re}from"./operatorConvexHull-BOUxTPu9.js";import{t as oe}from"./OperatorCrosses-DYGONmE0.js";import{i as se}from"./cutOperator-DhZ0CxqQ.js";import{l as ae}from"./densifyOperator-BbV2luZW.js";import{m as ne}from"./differenceOperator-BH9s0G8T.js";import{N as ie}from"./ProjectionTransformation-C_HFIKg2.js";import{i as ce}from"./distanceOperator-DR0UIleG.js";import{l as ue}from"./equalsOperator-BXCKCSLP.js";import{c as me}from"./generalizeOperator-pJll8twd.js";import{l as fe}from"./intersectionOperator-NP0PVJ5Y.js";import{p as pe}from"./intersectsOperator-BYqWT6vZ.js";import{c as le}from"./labelPointOperator-BKDnI1H2.js";import{n as ye}from"./lengthOperator-BhCIAW9-.js";import{t as _e}from"./OperatorOverlaps-ChZkuXQk.js";import{g as ge}from"./proximityOperator-CiCvjdhF.js";import{y as de}from"./relateOperator-CoQ7JqMH.js";import{f as be}from"./simplifyOperator-BlWKWDwI.js";import{i as ve}from"./symmetricDifferenceOperator-sXcfSDh7.js";import{t as xe}from"./OperatorTouches-B5vgR6uQ.js";import{s as Se,o as je,r as Oe}from"./operatorUnion-CGzDuCvJ.js";import{t as Ce}from"./OperatorWithin-DAGeBUkW.js";import{executeOffset as Ge}from"./offset-BIY6tCu7.js";let _,d,b,v,M;function z(){return!!_&&q()}async function T(){if(!z()){const[e]=await Promise.all([import("./apiConverter-r-Dz8Yjc.js"),h()]);_=e.fromGeometry,d=e.fromSpatialReference,b=e.getSpatialReference,v=e.toPolygon,M=D()}}function Pe(e,t,s={}){let{curveType:a="geodesic",maxDeviation:o=NaN,unit:u}=s;u&&(t=l(t,u,"meters"),o&&(o=l(o,u,"meters")));const c=b(e);return v(A(_(e),d(c),P[a],t,o),c)}function we(e,t,s={}){let{curveType:a="geodesic",maxDeviation:o=NaN,union:u=!1,unit:c}=s;c&&(t=t.map(m=>l(m,c,"meters")),o&&(o=l(o,c,"meters")));const f=e.map(_),p=b(e);return I(f,d(p),P[a],t,o,u).map(m=>v(m,p)).filter(G)}const Me=Object.freeze(Object.defineProperty({__proto__:null,execute:Pe,executeMany:we,isLoaded:z,load:T,get supportsCurves(){return M}},Symbol.toStringTag,{value:"Module"}));function ze(e,t,s={}){const{unit:a}=s,o=i(e);return a&&(t=g(t,a,o)),w(Z(r(e),n(o),t),o)}function Te(e,t,s={}){let{maxDeviation:a=NaN,maxVerticesInFullCircle:o=96,union:u=!1,unit:c}=s;const f=i(e);c&&(t=t.map(m=>g(m,c,f)),a&&(a=g(a,c,f)));const p=e.map(r);return X(p,n(f),t,a,o,u).map(m=>w(m,f)).filter(G)}const Re=V(),Ne=Object.freeze(Object.defineProperty({__proto__:null,execute:ze,executeMany:Te,supportsCurves:Re},Symbol.toStringTag,{value:"Module"}));function he(e){const t=i(e);return y(re(r(e)),t)}function De(e,t={}){const{merge:s=!1}=t,a=e.map(r),o=i(e);return te(a,s).map(u=>y(u,o))}function qe(e){return ee(r(e))}const Ie=U(),Ae=Object.freeze(Object.defineProperty({__proto__:null,execute:he,executeMany:De,isConvex:qe,supportsCurves:Ie},Symbol.toStringTag,{value:"Module"})),x=new oe;function Be(e){const t=i(e);return x.accelerateGeometry(r(e),n(t),1)}function Je(e,t){return x.execute(r(e),r(t),n(e.spatialReference),null)}const Le=x.supportsCurves(),We=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:Be,execute:Je,supportsCurves:Le},Symbol.toStringTag,{value:"Module"})),S=new ie;function Ye(e){const t=i(e);return S.accelerateGeometry(r(e),n(t),1)}function Ee(e,t){return S.execute(r(e),r(t),n(e.spatialReference))}const Fe=S.supportsCurves(),He=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:Ye,execute:Ee,supportsCurves:Fe},Symbol.toStringTag,{value:"Module"})),j=new _e;function Qe(e){const t=i(e);return j.accelerateGeometry(r(e),n(t),1)}function Ve(e,t){return j.execute(r(e),r(t),n(e.spatialReference),null)}const Xe=j.supportsCurves(),Ze=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:Qe,execute:Ve,supportsCurves:Xe},Symbol.toStringTag,{value:"Module"})),O=new xe;function $e(e){const t=i(e);return O.accelerateGeometry(r(e),n(t),1)}function ke(e,t){return O.execute(r(e),r(t),n(e.spatialReference),null)}const Ke=O.supportsCurves(),Ue=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:$e,execute:ke,supportsCurves:Ke},Symbol.toStringTag,{value:"Module"}));function et(e,t){const s=i(e);return y(Oe(r(e),r(t),n(s)),s)}function tt(e){const t=e.map(r),s=i(e);return y(je(t,n(s)),s)}const rt=Se(),ot=Object.freeze(Object.defineProperty({__proto__:null,execute:et,executeMany:tt,supportsCurves:rt},Symbol.toStringTag,{value:"Module"})),C=new Ce;function st(e){const t=i(e);return C.accelerateGeometry(r(e),n(t),1)}function at(e,t){return C.execute(r(e),r(t),n(e.spatialReference),null)}const nt=C.supportsCurves(),it=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:st,execute:at,supportsCurves:nt},Symbol.toStringTag,{value:"Module"}));function ct(e,t,s,a){const o=new H().rotate(t,s,a);return N(e,o)}const ut=new Set([5,6,7,10,11,12]);function mt(e){const t=new R;return!F(e,t)&&ut.has(t.m_reason)}async function ft(){await Promise.all([B(),T(),L(),Y()])}export{Q as area,Ne as buffer,$ as centroid,k as clip,K as contains,Ae as convexHull,We as crosses,se as cut,ae as densify,ne as difference,He as disjoint,ce as distance,ue as equals,Ge as executeOffset,me as generalize,Me as geodesicBuffer,J as geodeticArea,W as geodeticDensify,E as geodeticLength,fe as intersection,pe as intersects,mt as isSelfIntersecting,le as labelPoint,ye as length,ft as loadAll,Ze as overlaps,ge as proximity,de as relate,ct as rotate,be as simplify,ve as symmetricDifference,Ue as touches,ot as union,it as within};
