import{aH as G,k as d,o as g,A as L,aD as I,dL as O,aG as Q,s as P,V as U,bV as _,dq as R,ao as E,cv as M,eW as q,aZ as z,eX as j,au as k,eY as D,D as S,eZ as W,br as Z,bt as C,bL as N}from"./main-CvsyIoCL.js";import{H as X}from"./languageUtils-nHQgHS31.js";import{o as A}from"./drapedUtils-DqzgwWNv.js";import{n as Y,p as B}from"./popupUtils-Baw0DIJ5.js";const V=G();let b=null;function J(t,e){return e.type==="tile"||e.type==="map-image"}let y=class extends I{constructor(t){super(t),this._featuresResolutions=new WeakMap,this.highlightGraphics=null,this.highlightGraphicUpdated=null,this.updateHighlightedFeatures=O(async e=>{this.destroyed||this.updatingHandles.addPromise(this._updateHighlightedFeaturesGeometries(e).catch(()=>{}))})}initialize(){const t=e=>{this.updatingHandles.addPromise(this._updateHighlightedFeaturesSymbols(e).catch(()=>{})),this.updateHighlightedFeatures(this._highlightGeometriesResolution)};this.addHandles([Q(()=>this.highlightGraphics,"change",e=>t(e.added),{onListenerAdd:e=>t(e)})])}async fetchPopupFeaturesAtLocation(t,e){const{layerView:{layer:r,view:{scale:o}}}=this;if(!t)throw new P("fetchPopupFeatures:invalid-area","Nothing to fetch without area",{layer:r});const s=K(r.sublayers,o,e);if(!s.length)return[];const i=await ee(r,s);if(!((r.capabilities?.operations?.supportsIdentify??!0)&&r.version>=10.5)&&!i)throw new P("fetchPopupFeatures:not-supported","query operation is disabled for this service",{layer:r});return i?this._fetchPopupFeaturesUsingQueries(t,s,e):this._fetchPopupFeaturesUsingIdentify(t,s,e)}clearHighlights(){this.highlightGraphics?.removeAll()}highlight(t){const e=this.highlightGraphics;if(!t||!e)return V;let r=X(t)?[t]:U.isCollection(t)?t.toArray():Array.isArray(t)?t:[];if(r=r?.filter(_),(r?.length??0)===0)return V;for(const o of r){const{sourceLayer:s}=o;s!=null&&"geometryType"in s&&s.geometryType==="point"&&(o.visible=!1)}return e.addMany(r),G(()=>e.removeMany(r??[]))}async _updateHighlightedFeaturesSymbols(t){const{layerView:{view:e},highlightGraphics:r,highlightGraphicUpdated:o}=this;if(r&&o)for(const s of t){const i=s.sourceLayer&&"renderer"in s.sourceLayer&&s.sourceLayer.renderer;s.sourceLayer&&"geometryType"in s.sourceLayer&&s.sourceLayer.geometryType==="point"&&i&&"getSymbolAsync"in i&&i.getSymbolAsync(s).then(async a=>{a||=new R;let c=null;const u="visualVariables"in i?i.visualVariables?.find(n=>n.type==="size"):void 0;u&&(b||(b=(await import("./visualVariableUtils-CIDAKa7H.js")).getSize),c=b(u,s,{view:e.type,scale:e.scale,shape:a.type==="simple-marker"?a.style:null})),c||="width"in a&&"height"in a&&a.width!=null&&a.height!=null?Math.max(a.width,a.height):"size"in a?a.size:16,r.includes(s)&&(s.symbol=new R({style:"square",size:c,xoffset:"xoffset"in a?a.xoffset:0,yoffset:"yoffset"in a?a.yoffset:0}),o(s,"symbol"),s.visible=!0)})}}async _updateHighlightedFeaturesGeometries(t){const{layerView:{layer:e,view:r},highlightGraphics:o,highlightGraphicUpdated:s}=this;if(this._highlightGeometriesResolution=t,!s||!o?.length||!e.capabilities.operations.supportsQuery)return;const i=this._getTargetResolution(t),a=new Map;for(const n of o)if(!this._featuresResolutions.has(n)||this._featuresResolutions.get(n)>i){const p=n.sourceLayer;E(a,p,()=>new Map).set(n.getObjectId(),n)}const c=Array.from(a,([n,p])=>{const l=n.createQuery();return l.objectIds=[...p.keys()],l.outFields=[n.objectIdField],l.returnGeometry=!0,l.maxAllowableOffset=i,l.outSpatialReference=r.spatialReference,n.queryFeatures(l)}),u=await Promise.all(c);if(!this.destroyed)for(const{features:n}of u)for(const p of n){const l=p.sourceLayer,h=a.get(l).get(p.getObjectId());h&&o.includes(h)&&(h.geometry=p.geometry,s(h,"geometry"),this._featuresResolutions.set(h,i))}}_getTargetResolution(t){const e=t*M(this.layerView.view.spatialReference),r=e/16;return r<=10?0:t/e*r}async _fetchPopupFeaturesUsingIdentify(t,e,r){const o=await this._createIdentifyParameters(t,e,r);if(o==null)return[];const{results:s}=await q(this.layerView.layer.parsedUrl,o,r);return s.map(i=>i.feature)}async _createIdentifyParameters(t,e,r){const{floors:o,layer:s,timeExtent:i,view:{spatialReference:a,scale:c}}=this.layerView;if(!e.length)return null;await Promise.all(e.map(({sublayer:f})=>f.load(r).catch(()=>{})));const u=Math.min(z("mapservice-popup-identify-max-tolerance"),s.allSublayers.reduce((f,m)=>m.renderer?A({renderer:m.renderer,pointerType:r?.pointerType}):f,2)),n=this.createFetchPopupFeaturesQueryGeometry(t,u),p=j(c,a),l=Math.round(n.width/p),h=new k({xmin:n.center.x-p*l,ymin:n.center.y-p*l,xmax:n.center.x+p*l,ymax:n.center.y+p*l,spatialReference:n.spatialReference});return new D({floors:o,gdbVersion:"gdbVersion"in s?s.gdbVersion:void 0,geometry:t,height:l,layerOption:"popup",mapExtent:h,returnGeometry:!0,spatialReference:a,sublayers:s.sublayers,timeExtent:i,tolerance:u,width:l})}async _fetchPopupFeaturesUsingQueries(t,e,r){const{layerView:{floors:o,timeExtent:s}}=this,i=e.map(async({sublayer:a,popupTemplate:c})=>{if(await a.load(r).catch(()=>{}),a.capabilities&&!a.capabilities.operations.supportsQuery)return[];const u=a.createQuery(),n=A({renderer:a.renderer,pointerType:r?.pointerType}),p=this.createFetchPopupFeaturesQueryGeometry(t,n),l=new Set,[h]=await Promise.all([Y(a,c),a.renderer?.collectRequiredFields(l,a.fieldsIndex)]);S(r),W(l,a.fieldsIndex,h);const f=Array.from(l).sort();u.geometry=p,u.outFields=f,u.timeExtent=s;const m=Z(o,a);u.where=C(u.where,m);const v=this._getTargetResolution(p.width/n),x=await $(c);S(r);const F=a.geometryType==="point"||x&&x.arcadeUtils.hasGeometryOperations(c);F||(u.maxAllowableOffset=v);let{features:w}=await a.queryFeatures(u,r);const T=F?0:v;w=await te(a,w,r);for(const H of w)this._featuresResolutions.set(H,T);return w});return(await Promise.allSettled(i)).reduce((a,c)=>c.status==="fulfilled"?[...a,...c.value]:a,[]).filter(_)}};function K(t,e,r){const o=[];if(!t)return o;const s=i=>{const a=i.minScale===0||e<=i.minScale,c=i.maxScale===0||e>=i.maxScale;if(i.visible&&a&&c){if(i.sublayers)i.sublayers.forEach(s);else if(i.popupEnabled){const u=B(i,{...r,defaultPopupTemplateEnabled:!1});u!=null&&o.unshift({sublayer:i,popupTemplate:u})}}};return t.map(s),o}function $(t){return t.expressionInfos?.length||Array.isArray(t.content)&&t.content.some(e=>e.type==="expression")?N():Promise.resolve()}async function ee(t,e){if(t.capabilities?.operations?.supportsQuery)return!0;try{return await Promise.any(e.map(({sublayer:r})=>r.load().then(()=>r.capabilities.operations.supportsQuery)))}catch{return!1}}async function te(t,e,r){const o=t.renderer;return o&&"defaultSymbol"in o&&!o.defaultSymbol&&(e=o.valueExpression?await Promise.all(e.map(s=>o.getSymbolAsync(s,r).then(i=>i?s:null))).then(s=>s.filter(i=>i!=null)):e.filter(s=>o.getSymbol(s)!=null)),e}d([g({constructOnly:!0})],y.prototype,"createFetchPopupFeaturesQueryGeometry",void 0),d([g({constructOnly:!0})],y.prototype,"layerView",void 0),d([g({constructOnly:!0})],y.prototype,"highlightGraphics",void 0),d([g({constructOnly:!0})],y.prototype,"highlightGraphicUpdated",void 0),d([g({constructOnly:!0})],y.prototype,"updatingHandles",void 0),y=d([L("esri.views.layers.support.MapServiceLayerViewHelper")],y);export{y as R,J as _};
